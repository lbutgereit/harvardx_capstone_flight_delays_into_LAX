---
title: "Harvardx Capstone - Domestic Flight Arrivals Delays into LAX Airport"
author: "Laura Butgereit"
date: "08/05/2021"
output: 
  bookdown::pdf_document2:
    number_sections: true
    toc: true
    lof: yes
    keep_tex: true
    extra_dependencies: ["float"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      fig.pos="H", fig.height=6, fig.width=6, fig.align="center",
                      out.extra="")
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(lubridate)) install.packages("lubridate", repos = "http://cran.us.r-project.org")
if(!require(Metrics)) install.packages("Metrics", repos = "http://cran.us.r-project.org")
library(tidyverse)
library(lubridate)
library(stringr)
library(dplyr)
if(!require(kableExtra)) install.packages("kableExtra", repos = "http://cran.us.r-project.org")
```

```{r, echo=FALSE}
#
# this is the theme for the graphs and a few functions to
# ensure that all the graphs look similar
#
# theme from https://emanuelaf.github.io/own-ggplot-theme.html
#
my_theme <- function() {
  theme(
    # add border 1)
    panel.border = element_rect(colour = "deepskyblue4", fill = NA, linetype = 1),
    # color background 2)
    panel.background = element_rect(fill = "aliceblue"),
    # modify grid 3)
    panel.grid.major.x = element_line(colour = "deepskyblue4", linetype = 3, size = 0.5),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y =  element_line(colour = "deepskyblue4", linetype = 3, size = 0.5),
    panel.grid.minor.y = element_blank(),
    # modify text, axis and colour 4) and 5)
    axis.text = element_text(colour = "deepskyblue4"),
    axis.title = element_text(colour = "deepskyblue4"),
    axis.ticks = element_line(colour = "deepskyblue4"),
    # legend at the bottom 6)
    legend.position = "top",
    #plot.fill = "deepskyblue4",
    plot.title = element_text(colour = "deepskyblue4", hjust = 0.5),
  )
}
update_geom_defaults("bar", list(fill = "deepskyblue4", alpha = 0.6, color = "deepskyblue4"))   # color was blue
update_geom_defaults("point", list(fill = "deepskyblue4", alpha = 0.6, color = "deepskyblue4"))  # color was blue
update_geom_defaults("smooth", list(fill = "deepskyblue4", alpha = 0.6, color = "violet"))
update_geom_defaults("boxplot", list(fill = "deepskyblue4", alpha = 0.6, outlier.color = "violet"))

#
# this function is to ensure that all histograms 
# have a similar look and feel
#
#
histogram_graph <- function(data, x, bins=10) {
  p <- ggplot(aes(x), data=data) +
    #scale_y_continuous()+
    scale_y_log10() +
    #geom_histogram(bins=bins)  +
    geom_histogram(binwidth=30) +
    #scale_x_log10() +
    ylab("Quantity") +
    my_theme()
  p
}

#
# this function is to ensure that all graphs which
# have arrival delays on the Y axis have a similar
# scale for comparison purposes
#
#
arrival_delay_graph <- function(data, x, y) {
  p <- ggplot(aes(x, y), data=data) +
    scale_y_continuous(limits=c(mean(non_validation$ArrDelay) - sd(non_validation$ArrDelay),
			        mean(non_validation$ArrDelay) + sd(non_validation$ArrDelay)))+
    geom_point() + 
    geom_smooth(method = "loess", formula="y ~ x") +
    ylab("Average arrival delay (minutes)") +
    my_theme()
  p
}

#
#
#
bar_graph <- function(data, x, y) {
  p <- ggplot(aes(x, y), data=data) +
    geom_bar(stat = "identity") +
    my_theme()
  p
}

#
# boxplot function to ensure all boxplots looks
# similar
#
boxplot_graph <- function(data, x) {
 p <- ggplot(aes(x, y), data=data) +
    geom_boxplot() +
    my_theme()
 p
}

#
# functions for time handling
#
previous_half_hour <- function(time) {
  minute <- time %% 100
  hour <- time - minute
  minute <- ifelse(minute < 30, 0, 30)
  hour+minute
}

```

\listoffigures

\listoftables
\newpage

# Introduction

Wada, wada, wada,

This project was part of a Capstone project in Harvardx's *Professional Certificate in Data Science*.

Section \@ref(environment) describes the computational environment where this
research was executed.  This section also itemizes any modifications that might
have needed to be done in order to process the large data files.

Section \@ref(download) describes issues which were encountered in downloading the
required data files.  This section provides various strategies which were
utilized to handle these issues. 

Section \@ref(exploration) of this paper describes the exploration into the dataset.
This section includes numerical values and some histograms of distributions.
After the initial exploration, the training dataset was reshaped to expose
more information. 

Section \@ref(model) describes the various investigations into possible
models to be able to predict the ratings given to a movie.  There were a
number of different strategies which were investigated.  Each model is
described along with the RMSE (root mean square error) for that model.


Conclusions can be found in Section \@ref(conclusions).

Before continuing with this document, the author wishes to share the wise words of Donald Knuth (1984).  In his journal
paper entitled *Literate Programming* he states:

\begin{quotation}
Let us change our traditional attitude to the construction of [computer] programs:  Instead of imagining that our 
main task is to instruct a 
\begin{em}
computer
\end{em}
what to do,  let us concentrate rather on explaining to 
\begin{em}
human beings
\end{em}
what we want a computer to do. 

The practitioner of literate programming can be regarded as an essayist,  whose  main concern  is with 
exposition and  excellence  of style.  
Such an author, with thesaurus in hand, chooses the names of variables carefully and explains what each 
variable means.  He or she strives
for a program that is comprehensible because its concepts have been introduced in an order that is best for human
understanding...
\end{quotation}

The author eschews variables such as *mu* and *y_hat* (which may be familiar to data science practitioners and
statisticians), in favour of more descriptive variables such as *overall_average* and *predicted_rating*.  Although this practice may
be in conflict with code examples in (Irizarry, 2021), the author is employed in the IT industry and is attending this
course with the view of integrating R (running in an automated fashion started by Java programs) into a Spring Boot environment.  As such the practices of good
naming conventions in source code are well ingrained.

\newpage
# Compute Environment and Memory issues {#environment}

The analyses presented in the paper were done on a Dell XPS 13 9380 13.3" Core i7-8565U Notebook. The notebook has 8GB memory and a Core i7-8565U processor.  The notebook was running Ubuntu 20.04.2 LTS with R 4.0.3 installed.

## Adding more swap space

There were memory issues and an additional 4G swap space was configured on the notebook with the following Linux commands executed as superuser:

```{r, eval=FALSE, echo=TRUE}
fallocate -l 4G /harvardx_swapspace
chmod 600 /harvardx_swapspace
mkswap /harvardx_swapspace
swapon /harvardx_swapspace
```

In order to have this swapspace available automatically when the notebook boots up
an entry needed to be made in the file

```{r, eval=FALSE, echo=TRUE}
/etc/fstab
```

which looks like

```{r, eval=FALSE, echo=TRUE}
/harvardx_swapfile none swap sw 0 0
```

## Modifying *swappiness*

The *swappiness* value defines how aggressively the Linux kernel swaps memory pages to swap devices.  The value ranges
between zero and one hundred (Ljubuncic, 2015).  A higher *swappiness* value implies a stronger preference toward
swapping more readily.  A lower value implies not swapping (Love, 2013).  The value can be configured on this file

```{r, eval=FALSE, echo=TRUE}
/etc/sysctl.conf
```

The entry looks like

```{r, eval=FALSE, echo=TRUE}
vm.swappiness=10
```

This change was made to stop Linux swapping excessively.

## Request extra memory when executing R

In order to successfully build and execute, the scripts were run in R and not Rstudio with the following
command

```{r, eval=FALSE, echo=TRUE}
R -max-mem-size=7000M --vanilla < Butgereit-script.R  > output.txt
```

The report was generated with the following command
```{r, eval=FALSE, echo=TRUE}
Rscript -e "rmarkdown::render('Butgereit-report.Rmd')"
```

\newpage
# Downloading, unzipping, and validating data {#download}

The author lives in a rural area of Africa where download speeds are slow and connections often break.  For that reason, the code supplied by the Edx website for downloading data was modified slightly to include a *timeout* parameter.  *The code reviewer may need to increase the parameter depending on his or her local circumstances.*  The code then attempted to download 
the required zip file, store the file locally, and then to check the size of the downloaded file to verify that the entire data file was downloaded.  If the download and size check did not succeed, error messages are printed and the script is stopped.  If the download and size check did succeed, only then is the data unzipped.

## Set up pseudo-constants

First a handful of pseudo-constants were set up

```{r, echo=TRUE}
download_timeout <- 600 # seconds == 10 minutes
on_time_performance_url <- 
"https://dax-cdn.cdn.appdomain.cloud/dax-airline/1.0.1/airline_2m.tar.gz"
on_time_performance_gz <- "airline_2m.tar.gz"
on_time_performance_gz_size <- 151681776
on_time_performance_csv <- "airline_2m.csv"
on_time_performance_csv_size <- 882162600
on_time_performance_rda <- "on_time_performance.rda"
validation_rda <- "validation.rda"
non_validation_rda <- "non_validation.rda"
test_rda <- "test.rda"
train_rda <- "train.rda"
build_models <- FALSE
destination_airport <- "LAX"

```

## Download zip file and check sizes

The script was broken up into sections where the sizes of all the downloaded files were tested before the next step was executed

```{r, echo=TRUE}
#
# if the gz file has not been downloaded or if it is
# the wrong size, download it
#
if ( (!file.exists(on_time_performance_gz)) ||
     (file.info(on_time_performance_gz)$size != on_time_performance_gz_size) ) {

        #
        # Download gz file
        #
        print(paste("file", on_time_performance_gz, 
		"does not exist or is the wrong size", sep=" "))
        print("Downloading it")
        options(timeout = download_timeout)
        download.file(on_time_performance_url, on_time_performance_gz)
        print(paste("Downloaded", file.info(on_time_performance_gz)$size, 
		"bytes"))

        #
        # check to see if the entire file got downloaded
        #
        if ( file.info(on_time_performance_gz)$size == on_time_performance_gz_size) {
                print(paste(on_time_performance_gz, "downloaded OK", sep=" "))
        } else {
                print(paste(on_time_performance_gz, 
			"was not completely downloaded", sep=" "))
                print(paste("You can download it through your browser ",
			"by pointing your browser to"), sep="")
                print(on_time_performance-url)
                stop()
        }
}
```

## Untar file and check sizes

The downloaded file is in gzipped tar format.  The R function *untar* does both a gzip decompress and an untar of the files


```{r echo=TRUE}
#
# if the csv file does not exist or is the wrong size
# or if it is older than the gz file, then untar the
# gz file
#
if ( (!file.exists(on_time_performance_csv)) |
     (file.info(on_time_performance_csv)$size != on_time_performance_csv_size) ||
     (file.info(on_time_performance_gz)$ctime > file.info(on_time_performance_csv)$ctime) ) {

        #
        # untar (inclues gz decompress)
        #
        print(paste("Untaring (will also do a gz decompress)", on_time_performance_gz, sep=" "))
        untar(on_time_performance_gz)

        #
        # check to see if the files sizes are correct
        #
        if ( file.info(on_time_performance_csv)$size == on_time_performance_csv_size) {
                print(paste(on_time_performance_csv, "untared OK", sep=" "))
        } else {
                print(paste(on_time_performance_csv, 
			"was not untarred correctly", sep=" "))
                print(paste("You can try decrompressing and untaring ",
			"it your self and rerunning this script"), sep="")
                stop()
        }
}

```

\newpage
# Extracting and Creating datasets

The original downloaded file contained numerous pieces of information.

```{r, eval=TRUE, echo=TRUE}
csv <- read.csv(on_time_performance_csv, nrows=2)
numCols <- ncol(csv)
headings <- names(csv)
```
There are `r numCols` columns in the original data file.


```{r, eval=FALSE, echo=FALSE}
df %>% knitr::kable(caption="Headings in Original Dataset",
                         label="results") %>% kableExtra::kable_styling(latex_options="hold_position")
```
Many of these columns were empty and many were not relevant to the issue at hand.  The author
followed an interative approach into determining which columns were important.  An additional
boolean column was added which indicated whether or not the flight was late in arriving.

```{r, eval=TRUE, echo=TRUE}
#
# if the on_time_performance_rda file does not exist,
# or if the csv file is younger than it, then rebuild it
#
if ( (!file.exists(on_time_performance_rda)) ||
     (file.info(on_time_performance_csv)$ctime > file.info(on_time_performance_rda)$ctime) ) {

        #
        # read in the csv
        #
        print("Reading data file")
        csv <- read.csv(on_time_performance_csv)
        print("read csv")

        #
        # filter out only flights landing at destination_airport
        # select the columns which might interest us (human choice)
        # only keep complete cases
        # add a flag for Late
        #
        on_time_performance <- csv %>%
                filter(Dest == destination_airport) %>%
                select(Year, Month, DayofMonth, DayOfWeek,
                        DOT_ID_Reporting_Airline,
                        Flight_Number_Reporting_Airline,
                        OriginAirportID,
                        Tail_Number,
                        Distance,
                        AirTime,
                        ArrDel15,
                        DepTime, ArrTime, ArrDelay) %>%
                filter(complete.cases(.)) %>%           # NB the full stop
		mutate(Late = ifelse(ArrDelay > 0, 1, 0),
		       departure_slot = previous_half_hour(DepTime),
		       arrival_slot = previous_half_hour(ArrTime))

        print("filtered out NAs and selected columns")
        save(on_time_performance, file=on_time_performance_rda)
        print(paste("Saved", on_time_performance_rda))
}
```

From this newly created dataset, four subsets were created.  The first subset was to extract a validation
set which would be put aside and not accessed until the final model was going to be evaluation.  The
second subset was the remaining elements which were not in the validation set.  This second subset (the
non validation dataset), was subdivided into a training set and a testing set.  All four of these
subsets were stored on intermediate R objects.

```{r, eval=TRUE, echo=TRUE}
#
# if validation, train, and test do not exist or if
# one of them is younger than the big rda
#
# make sure that the Late flag is equitably distributed
#
if ( !file.exists(test_rda) || !file.exists(train_rda) || !file.exists(validation_rda) ||
     !file.exists(non_validation_rda) ||
     (file.info(on_time_performance_rda)$ctime > file.info(validation_rda)) ||
     (file.info(on_time_performance_rda)$ctime > file.info(non_validation_rda)) ||
     (file.info(on_time_performance_rda)$ctime > file.info(train_rda)) ||
     (file.info(on_time_performance_rda)$ctime > file.info(test_rda))) {

        set.seed(1, sample.kind="Rounding")
        load(on_time_performance_rda)

        #
        # make validation and non-validation datasets
        #
        validation_index <- createDataPartition(y=on_time_performance$Late, times=1, p=0.1, list=FALSE)
        validation <- on_time_performance[validation_index,]
        non_validation <- on_time_performance[-validation_index,]


        #
        # divide the non-validation dataset into test and train
        #
        test_index <- createDataPartition(y=non_validation$Late, times=1, p=0.1, list=FALSE)
        test <- non_validation[test_index,]
        train <- non_validation[-test_index,]

        #
        # save on intermediate data objects
        #
        save(test, file=test_rda)
        save(train, file=train_rda)
        save(validation, file=validation_rda)
        save(non_validation, file=non_validation_rda)

        #
        # free up memory
        #
        rm(test, train, validation, non_validation, on_time_performance)
}

```

```{r eval=TRUE, echo=FALSE}
load(non_validation_rda)
nrow_non_validation <- nrow(non_validation)
rm(non_validation)
load(validation_rda)
nrow_validation <- nrow(validation)
rm(validation)
load(train_rda)
nrow_train <- nrow(train)
rm(train)
load(test_rda)
nrow_test <- nrow(test)
rm(test)
datasets <- c("Non-validation", "Validation", "Train", "Test")
numRows <- c(nrow_non_validation, nrow_validation, nrow_train, nrow_test)
df <- data.frame(datasets, numRows)
```

The number of rows in each dataset can be seen in Table \@ref(tab:sizes)

\begin{center}
```{r echo=FALSE}
df %>% knitr::kable(caption="Sizes of various datasets",
                         label="sizes") %>% kableExtra::kable_styling(latex_options="hold_position")
```
\end{center}


\newpage
# Exploratory Analysis {#exploration}

All values and graphs in this exploratory section refer only to the
*non_validation* set.  This includes the training set and test set combined, but
specifically excludes the validation set which was extracted and saved
for future use.  This section explores the data and reports on interesting
findings.

There are two sub-sections.  The first sub-section looks at specific characteristics
of the *ArrDelay* data field.  It is important to remember that this data field could be
positive (a delay) or negative (flight arrived early).  The second sub-section look
specifically at the boolean field *Late* which indicates whether or not the flight
was late.

## Investigating *ArrDelay*

### Arrival delays

Although the term is called *ArrDelay*, the value can be positive (indicating
an actual delay) or negative (indicating that the flight arrived early).
Statistics about the *ArrDelay* field can be seen in Table
\@ref(tab:ArrDelayStats)

\begin{center}
```{r echo=FALSE}
load(non_validation_rda)
Measurement <- c("Minimum", "Maximum", "Mean", "Std Dev")
Value <- c(min(non_validation$ArrDelay), max(non_validation$ArrDelay),
           mean(non_validation$ArrDelay), sd(non_validation$ArrDelay))
df <- data.frame(Measurement, Value)
df %>% knitr::kable(caption="Statistics about arrival delay times",
                         label="ArrDelayStats") %>% kableExtra::kable_styling(latex_options="hold_position")
```
\end{center}

The distribution of arrival delay values can be seen in 
Figure \@ref(fig:distribution-arrival-delays).

```{r, distribution-arrival-delays, fig.cap="Distribution of arrival delays"}
flights_per_delays <- non_validation %>% group_by(ArrDelay) %>%
  summarize(number_of_flights = n(), ArrDelay = first(ArrDelay))
options(scipen=100000)
bar_graph(x = flights_per_delays$number_of_flights,
	  y = flights_per_delays$number_of_flights,
                data=flights_per_delays) +
  xlab("Arrival delay (minutes)") +
  ylab("Number of flights")
```
```{r, eval=TRUE, echo=FALSE}
rm(flights_per_delays)  # free up memory
```
### Years

The data spanned a number of years from `r min(non_validation$Year)` to 
`r max(non_validation$Year)`.  A distribution of the flights through the 
years can be seen in Figure \@ref(fig:distribution-flights-by-year)

```{r, distribution-flights-by-year, fig.cap="Distribution of flights by year"}
flights_per_year <- non_validation %>% group_by(Year) %>%
  summarize(number_of_flights = n(), Year = first(Year))
bar_graph(x = flights_per_year$Year, y = flights_per_year$number_of_flights,
                data=flights_per_year) +
  xlab("Year") +
  ylab("Number of flights")
```
```{r, eval=TRUE, echo=FALSE}
rm(flights_per_year)  # free up memory
```

# Average delay by year

The average arrival delay by year can be seen in Figure \@ref(fig:average-delay-by-year)

```{r, average-delay-by-year, fig.cap="Average arrival delay by year"}
flights_per_year <- non_validation %>% group_by(Year) %>%
  summarize(average_delay = mean(ArrDelay), Year = first(Year))
arrival_delay_graph(x = flights_per_year$Year, y = flights_per_year$average_delay,
                data=flights_per_year) +
  xlab("Year") 
```
```{r, eval=TRUE, echo=FALSE}
rm(flights_per_year)  # free up memory
```

From Figure \@ref(fig:average-delay-by-year) it is clear that the year of a flight is not
a predctor of the average arrival delay.

### Average delay by month

The month of the year (indicating the season and possible weather effects) could
influence arrival delays.  This relationship can be seen in Figure \@ref(fig:average-delay-by-month).


```{r, average-delay-by-month, fig.cap="Average arrival delay by month"}
flights_per_month <- non_validation %>% group_by(Month) %>%
  summarize(average_delay = mean(ArrDelay), Month = first(Month))
arrival_delay_graph(x = flights_per_month$Month, y = flights_per_month$average_delay,
                data=flights_per_month) +
  xlab("Month") +
  ylab("Average delay (minutes)") +
  scale_x_continuous(limits=c(1, 12), breaks=1:12,
            labels=c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
```
```{r, eval=TRUE, echo=FALSE}
rm(flights_per_month)  # free up memory
```

From \@ref(fig:average-delay-by-month) one might argue that there is a very slight increase
in average arrival delays in the summer months (June and July) and at the Christmas
season (December).  But the change is not significant.

### Arrival delay by day of the month

The day of the month could possibly influence arrival times with end of month traffic
being different than mid-month traffic.  This relationship can be seen in Figure
\@ref(fig:average-delay-by-day-of-month).

```{r, average-delay-by-day-of-month, fig.cap="Average arrival delay by day of the month"}
flights_per_day <- non_validation %>% group_by(DayofMonth) %>%
  summarize(average_delay = mean(ArrDelay), DayofMonth = first(DayofMonth))
arrival_delay_graph(x = flights_per_day$DayofMonth, y = flights_per_day$average_delay,
                data=flights_per_day) +
  xlab("Day of the Month") +
  scale_x_continuous(limits=c(1, 31), breaks=1:31)

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_per_day)  # free up memory
```

Although one may argue that Figure \@ref(fig:average-delay-by-day-of-month) shows a very
slight decrease in average delays at the end of them month, that decrease is not
significant.

### Arrival delay by day of the week

The day of the week could possibly influence arrival times with weekend traffic
geting different than weekday traffic.  This relationship can be seen in Figure
\@ref(fig:average-delay-by-day).

```{r, average-delay-by-day, fig.cap="Average arrival delay by day of the week"}
flights_per_day <- non_validation %>% group_by(DayOfWeek) %>%
  summarize(average_delay = mean(ArrDelay), DayOfWeek = first(DayOfWeek))
arrival_delay_graph(x = flights_per_day$DayOfWeek, y = flights_per_day$average_delay,
                data=flights_per_day) +
  xlab("Day of the Week") +
  ylab("Average delay (minutes)") +
  scale_x_continuous(limits=c(1, 7), breaks=1:7,
                     labels=c("Sun", "Mon", "Tue", "Wed", "Thu",
                              "Fri", "Sat"))

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_per_day)  # free up memory
```

Figure \@ref(fig:average-delay-by-day) clearly shows that day of the month is not
a predictor of arrival delays.

### Arrival delay by origin airport

The airport where the flight originated may influence whether or not the flight arrives
late at the destination airport.  This can be seen in Figure \@ref(fig:average-delay-by-origin-airport)

```{r, average-delay-by-origin-airport, fig.cap="Average arrival delay by origin airport"}
flights_by_origin_airport <- non_validation %>% group_by(OriginAirportID) %>%
  summarize(average_delay = mean(ArrDelay), OriginAirportID = first(OriginAirportID))
arrival_delay_graph(
    x = reorder(flights_by_origin_airport$OriginAirportID, -flights_by_origin_airport$average_delay),
    y = flights_by_origin_airport$average_delay,
    data=flights_by_origin_airport) +
  xlab("Departing airport (arranged in descending order of delay)") +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.grid.major.x =  element_line(colour = "white", linetype = 3, size = 0.5),
        panel.grid.minor.x = element_blank())

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_origin_airport)  # free up memory
```

As can be seen in Figure \@ref(fig:average-delay-by-origin-airport), the airport from which
a flight departs or originates is influential in determining whether or not the flight arrives on time
at its destination.  This could be because the airport of origin may consistently delay
planes from departing on time or perhaps the airport of origin may consistently have
foggy weather.  This must be investigated further.

### Arrival delay by airline

The airline itself may be an influencing factor on whether or not a flight arrives
on time.  This relationship can be seen in \@ref(fig:average-delay-by-airline).

```{r, average-delay-by-airline, fig.cap="Average arrival delay by airline"}
flights_by_airline <- non_validation %>% group_by(DOT_ID_Reporting_Airline) %>%
  summarize(average_delay = mean(ArrDelay), 
		DOT_ID_Reporting_Airline = first(DOT_ID_Reporting_Airline))
arrival_delay_graph(
    x = reorder(flights_by_airline$DOT_ID_Reporting_Airline, 
		-flights_by_airline$average_delay),
    y = flights_by_airline$average_delay,
    data=flights_by_airline) +
  xlab("Airline (arranged in descending order of delay)")  +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.grid.major.x =  element_line(colour = "white", linetype = 3, size = 0.5),
        panel.grid.minor.x = element_blank())


```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_flight_number)  # free up memory
```

It is clear from \@ref(fig:average-delay-by-airline) that the airline itself is influential
in determining whether or not its own flights arrive on time.  This is intuitive.  Some
airline companies pride themselves on their *on time arrival* statistics.

### Arrival delay by flight number

The flight itself may determine whether or not it is late in arriving.  This could be due
to the departing airport (which would be the same for all flights with the same flight number)
and also to the airline itself.  It could possibly be because of the crew which is assigned 
to this flight.  This relationship can be seen in Figure \@ref(fig:average-delay-by-flight-number).

```{r, average-delay-by-flight-number, fig.cap="Average arrival delay by flight number"}
flights_by_flight_number <- non_validation %>% group_by(Flight_Number_Reporting_Airline) %>%
  summarize(average_delay = mean(ArrDelay), 
		Flight_Number_Reporting_Airline = first(Flight_Number_Reporting_Airline))
arrival_delay_graph(
    x = reorder(flights_by_flight_number$Flight_Number_Reporting_Airline, 
		-flights_by_flight_number$average_delay),
    y = flights_by_flight_number$average_delay,
    data=flights_by_flight_number) +
  xlab("Flight number (arranged in descending order of delay)") +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.grid.major.x =  element_line(colour = "white", linetype = 3, size = 0.5),
        panel.grid.minor.x = element_blank())


```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_flight_number)  # free up memory
```

It is clear from Figure \@ref(fig:average-delay-by-flight-number) that the scheduled
flight number itself is a predictor of possible arrival delays for that flight.  This
must be investigated further.  Care must also be taken to not allow airport of origin,
airline, and flight number to over emphasize the same fact.

### Arrival delay by tail number (specific airplane)

Physical airplanes have unique tail numbers. The specific physical airplane tself may 
determine whether or not it is late in arriving.  This may indicate that this
specific physical airplane flies faster or slower.  This relationship can be seen
in Figure \@ref(fig:average-delay-by-tail-number).

```{r, average-delay-by-tail-number, fig.cap="Average arrival delay by tail number"}
flights_by_tail_number <- non_validation %>% group_by(Tail_Number) %>%
  summarize(average_delay = mean(ArrDelay), 
		Tail_Number = first(Tail_Number))
arrival_delay_graph(
    x = reorder(flights_by_tail_number$Tail_Number, 
		-flights_by_tail_number$average_delay),
    y = flights_by_tail_number$average_delay,
    data=flights_by_tail_number) +
  xlab("Tail number (arranged in descending order of delay)") +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.grid.major.x =  element_line(colour = "white", linetype = 3, size = 0.5),
        panel.grid.minor.x = element_blank())


```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_flight_number)  # free up memory
```

From Figure \@ref(fig:average-delay-by-tail-number), it is clear that the tail number
is a predictor of arrival delays.  But care must be taken to not allow the airport of
origin, airline, flight number, and tail number to over emphasize some common
fact.

### Arrival delay by distance flown

The distance of a flight may influence whether or not there is a delay in arrival.
This relationship can be seen in Figure \@ref(fig:average-delay-by-distance).

```{r, average-delay-by-distance, fig.cap="Average arrival delay by distance flown"}
flights_by_distance <- non_validation %>% group_by(Distance) %>%
  summarize(average_delay = mean(ArrDelay), 
		Distance = first(Distance))
arrival_delay_graph(
    x = flights_by_distance$Distance, 
    y = flights_by_distance$average_delay,
    data=flights_by_distance) +
  xlab("Distance (miles)") 

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_flight_number)  # free up memory
```

### Arrival delay by time flying

The duration of a flight may influence whether or not there is a delay in arrival.
This relationship can be seen in Figure \@ref(fig:average-delay-by-airtime).

```{r, average-delay-by-airtime, fig.cap="Average arrival delay by airtime flown"}
flights_by_airtime <- non_validation %>% group_by(AirTime) %>%
  summarize(average_delay = mean(ArrDelay), 
		AirTime = first(Distance))
arrival_delay_graph(
    x = flights_by_airtime$AirTime, 
    y = flights_by_airtime$average_delay,
    data=flights_by_airtime) +
  xlab("Duration (minutes)") 

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_airtime)  # free up memory
```

Figure \@ref(fig:average-delay-by-airtime) shows that the time flying is LB

### Arrival delay by departure time

***LB*** why is this graph wonky

The departure time of the flight (when it should have departed from the airport of origin) could be
influential

```{r, average-delay-by-departure-time, fig.cap="Average arrival delay by departure time"}
flights_by_departure_time <- non_validation %>% group_by(departure_slot) %>%
  summarize(average_delay = mean(ArrDelay), 
		departure_slot = first(departure_slot))
arrival_delay_graph(
    x = flights_by_departure_time$departure_slot,
    y = flights_by_departure_time$average_delay,
    data=flights_by_departure_time) +
  xlab("Departure Time") +
  scale_x_continuous(limits=c(0, 2500), breaks=seq(0, 2400, 100))+
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust=1))

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_departure_time)  # free up memory
```

### Arrival delay by arrival time

The arrival time of the flight (when it should have arrived at the destination airport) could be
influential in predicting arrival delays.  This relationship can be seen in \@ref(fig:average-delay-by-arrival-time)


```{r, average-delay-by-arrival-time, fig.cap="Average arrival delay by arrival time"}
flights_by_arrival_time <- non_validation %>% group_by(arrival_slot) %>%
  summarize(average_delay = mean(ArrDelay), 
		arrival_slot = first(arrival_slot))
arrival_delay_graph(
    x = flights_by_arrival_time$arrival_slot,
    y = flights_by_arrival_time$average_delay,
    data=flights_by_arrival_time) +
  xlab("Arrival Time") +  
  scale_x_continuous(limits=c(0, 2500), breaks=seq(0, 2400, 100))+
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust=1))

```
```{r, eval=TRUE, echo=FALSE}
rm(flights_by_arrival_time)  # free up memory
```

Figure \@ref(fig:average-delay-by-arrival-time) appears to so an increase in arrival delays between
approximately 21:00 and 4:00).  This could be important.  However, in analysing arrival times, it is important
to remember that the author could not determine if the arrival times were given in local time
at the destination airport (`r destination_airport` in this case) or in GMT (Greenwich Mean Time).  

## Investigating *Late*

This sub-section specifically looks at boolean field *Late* which is TRUE if the flight was late (arrived later than schedule)
and was FALSE otherwise.  This field did not cater for earlier arrivals.
Statistics about the *Late* field can be seen in Table \@ref(tab:LateStats)

\begin{center}
```{r echo=FALSE}
#load(non_validation_rda)
#Measurement <- c("Total Rows", "Late", "Not Late")
#Value <- c(nrow(non_validation), sum(non_validation$Late), sum(!non_validation$Late))
#df <- data.frame(Measurement, Value)
#df %>% knitr::kable(caption="Statistics about late arrivals",
                         #label="LateStats") %>% kableExtra::kable_styling(latex_options="hold_position")
```
\end{center}

## Summary

From this exploration, it is clear that the fields indicated in Table \@ref(tab:ImportantColumns) are important
and could assist in predicting arrival delays and whether or not a flight is late.

\begin{center}
```{r echo=FALSE}
Fields <- c("Airport of Origin", "Airline", "Flight Number", "Tail Number")
df <- data.frame(Fields)
df %>% knitr::kable(caption="Important columns in dataset",
                         label="ImportantColumns") %>% kableExtra::kable_styling(latex_options="hold_position")
```
\end{center}

\newpage
# Model Investigations and Results {#model}
\newpage
# Conclusion {#conclusions}

# Acknowledgements {-}

The author would like to thank Professor Irizarry and his team for creating a compelling and
effective course.  The exercises drew a person into the problem and enticed them to investigate
the data.  Thank you.

# References {-}


Irizarry, R.A., 2021, Introduction to Data Science.

Knuth, D.E., 1984. Literate programming. The Computer Journal, 27(2), pp.97-111.

Ljubuncic, I., 2015. Problem-solving in High Performance Computing: A Situational Awareness Approach with Linux. Morgan Kaufmann.

Love, R., 2013. Linux system programming: talking directly to the kernel and C library. O'Reilly Media, Inc.
